<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pick Your Power â€” Pixel Forest Menu</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root{--bg:#081026;--accent:#ffd599;--muted:#b6c7d9;}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:var(--bg);-webkit-font-smoothing:antialiased;}
  #app{position:relative;height:100vh;overflow:hidden;display:flex;align-items:center;justify-content:center;}
  canvas{display:block;width:100%;height:100%;image-rendering:pixelated;}
  .menu{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); text-align:center;
    color:var(--accent); text-shadow:0 6px 18px rgba(0,0,0,0.7); pointer-events:none;
  }
  .title{
    font-family:'Press Start 2P', monospace; font-size:30px; letter-spacing:2px; margin:0;
    color:var(--accent);
  }
  .prompt{
    margin-top:18px; font-family:'Press Start 2P', monospace; font-size:12px; color:var(--muted);
    letter-spacing:1px;
  }
  .menu.hidden{opacity:0; transform:translate(-50%,-46%) scale(.98); transition:opacity 260ms, transform 260ms;}
  @media (max-width:760px){ .title{font-size:18px} .prompt{font-size:10px} }
</style>
</head>
<body>
  <div id="app" role="main" aria-label="Pick Your Power intro">
    <canvas id="bg"></canvas>
    <div class="menu" id="menu" aria-hidden="false">
      <div class="title">PICK YOUR POWER!</div>
      <div class="prompt">PRESS ANYWHERE TO CONTINUE</div>
    </div>
  </div>

<script>
/*
 Single-file pixel-art forest background with mouse-follow and low-res upscale.
 - Offscreen low-res canvas (pixel grid) is drawn each frame and upscaled to the visible canvas.
 - Background is a layered pixel forest: distant fog, mid trees, near trees, ground.
 - Mouse/touch influences horizontal parallax and slight vertical sway.
 - Menu remains: title + "press anywhere to continue"; clicking hides the menu.
*/

const canvas = document.getElementById('bg');
const ctx = canvas.getContext('2d', { alpha: false });
const menu = document.getElementById('menu');

let DPR = Math.min(window.devicePixelRatio || 1, 2);

// low-res "pixel" canvas size
let lowW = 320;
let lowH = 180;
const off = document.createElement('canvas');
const offCtx = off.getContext('2d', { alpha: false });

function fit() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  const aspect = w / h;
  lowW = Math.max(280, Math.min(640, Math.round(360 * Math.min(1.6, aspect))));
  lowH = Math.round(lowW * 9 / 16);
  off.width = lowW;
  off.height = lowH;
  canvas.width = lowW * DPR;
  canvas.height = lowH * DPR;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled = false;
  offCtx.imageSmoothingEnabled = false;
}
window.addEventListener('resize', fit);
fit();

/* state / pointer */
const state = { time:0, ox:0, oy:0 };
const pointer = { x: window.innerWidth/2, y: window.innerHeight/2, active:false };
window.addEventListener('mousemove', e => { pointer.x = e.clientX; pointer.y = e.clientY; pointer.active = true; });
window.addEventListener('touchmove', e => { const t = e.touches[0]; if(t){ pointer.x = t.clientX; pointer.y = t.clientY; pointer.active = true; } }, {passive:true});
window.addEventListener('touchstart', e => { const t = e.touches[0]; if(t){ pointer.x = t.clientX; pointer.y = t.clientY; pointer.active = true; } }, {passive:true});

/* helpers */
function lerp(a,b,t){ return a + (b-a)*t; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rand(min,max){ return min + Math.random()*(max-min); }

/* draw pixel forest on offscreen canvas */
function drawForest(c, w, h, st){
  // sky
  const sky = c.createLinearGradient(0,0,0,h);
  sky.addColorStop(0, '#ffeedd');
  sky.addColorStop(1, '#9fb7da');
  c.fillStyle = sky;
  c.fillRect(0,0,w,h);

  // distant fog band
  c.globalAlpha = 0.14;
  c.fillStyle = '#ffffff';
  c.fillRect(0, Math.floor(h*0.14), w, Math.floor(h*0.12));
  c.globalAlpha = 1;

  // distant ridge silhouettes
  drawRidgeline(c, w, h, Math.floor(h*0.32), '#c7e0f6', 0.06, st);
  drawRidgeline(c, w, h, Math.floor(h*0.40), '#9cc2e6', 0.12, st);

  // main forest mass mid layer
  drawTreeLayer(c, w, h, Math.floor(h*0.58), '#2f5f3a', 10, 0.28, st);

  // nearer trees with more detail and blossoms
  drawTreeLayer(c, w, h, Math.floor(h*0.74), '#1e4728', 8, 0.52, st, true);

  // ground strip
  c.fillStyle = '#061220';
  c.fillRect(0, Math.floor(h*0.86), w, h - Math.floor(h*0.86));

  // subtle vignette for depth
  c.globalCompositeOperation = 'multiply';
  const vg = c.createLinearGradient(0,0,0,h);
  vg.addColorStop(0, 'rgba(0,0,0,0)');
  vg.addColorStop(0.7, 'rgba(0,0,0,0.04)');
  vg.addColorStop(1, 'rgba(0,0,0,0.18)');
  c.fillStyle = vg;
  c.fillRect(0,0,w,h);
  c.globalCompositeOperation = 'source-over';
}

/* ridgeline (smooth jagged silhouette) */
function drawRidgeline(c, w, h, baseY, color, roughness, st){
  c.save();
  c.fillStyle = color;
  c.beginPath();
  c.moveTo(-20, h);
  const peaks = 8;
  for(let i=0;i<=peaks;i++){
    const px = Math.round((i/peaks)*(w+40) - 20);
    const noise = Math.sin(i*1.3 + st.time*0.6) * 8 * roughness;
    const py = Math.round(baseY - Math.abs(Math.cos(i*0.9 + st.time*0.4))* (120*roughness) + noise);
    c.lineTo(px, py);
  }
  c.lineTo(w+20, h);
  c.closePath();
  c.fill();
  c.restore();
}

/* tree layer draws many stylized trees across the width */
function drawTreeLayer(c, w, h, baseY, color, count, depthFactor, st, blossoms=false){
  c.save();
  // offset by pointer influence: horizontal parallax stronger for near layers
  const pxNorm = (pointer.x / Math.max(window.innerWidth,1) - 0.5) * 2; // -1..1
  const pyNorm = (pointer.y / Math.max(window.innerHeight,1) - 0.5) * 2;
  const ox = pxNorm * depthFactor * 12;
  const oy = pyNorm * depthFactor * 6;
  c.translate(ox, oy);

  for(let i=0;i<count;i++){
    const t = i/(count-1);
    // spread across width, small jitter
    const x = Math.round(t * w + (Math.sin(st.time*0.6 + i*1.3) * 8));
    const height = Math.round(48 + Math.random()*72);
    drawPixelTree(c, x + Math.round((Math.random()-0.5)*12), baseY, height, color, blossoms && i%2===0);
  }
  c.restore();
}

/* simple pixel-tree made of stacked rectangles (keeps pixel aesthetic) */
function drawPixelTree(c, x, baseY, hgt, color, blossoms=false){
  c.save();
  c.translate(x, baseY);
  // trunk
  c.fillStyle = '#3a2a1f';
  c.fillRect(-2, 0, 4, Math.round(hgt*0.25));
  // canopy as layered blocks to feel pixel-art
  const layers = 4;
  const layerW = Math.round(hgt * 0.7);
  for(let i=0;i<layers;i++){
    const w = Math.round(layerW - i* (layerW*0.18));
    const y = -Math.round(hgt*0.15) - i* Math.round(hgt*0.22);
    // color variation for depth
    const shade = i===0 ? color : shadeColor(color, -6*i);
    c.fillStyle = shade;
    c.fillRect(-Math.round(w/2), y, w, Math.round(hgt*0.22));
  }
  // optional blossoms: small scattered pink pixels
  if(blossoms){
    for(let p=0;p<6;p++){
      const bx = Math.round((Math.random()-0.5) * (layerW*0.7));
      const by = Math.round(-Math.random()*hgt*0.6 - 10);
      c.fillStyle = p%2===0 ? '#ffc6e1' : '#ffdbe9';
      c.fillRect(bx, by, 2, 2);
    }
  }
  c.restore();
}

/* utility: shade hex by percent */
function shadeColor(hex, percent){
  const f = hex.replace('#','');
  const R = parseInt(f.substring(0,2),16);
  const G = parseInt(f.substring(2,4),16);
  const B = parseInt(f.substring(4,6),16);
  const t = percent/100;
  const newR = Math.round(R + ((t>0?255:0) - R) * Math.abs(t));
  const newG = Math.round(G + ((t>0?255:0) - G) * Math.abs(t));
  const newB = Math.round(B + ((t>0?255:0) - B) * Math.abs(t));
  return `rgb(${clamp(newR,0,255)},${clamp(newG,0,255)},${clamp(newB,0,255)})`;
}

/* simpler clamp */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

/* animation loop */
let last = performance.now();
function loop(now){
  const dt = Math.min((now - last)/1000, 0.033);
  last = now;
  state.time += dt;

  // pointer normalized -1..1
  const nx = (pointer.x / Math.max(window.innerWidth,1) - 0.5) * 2;
  const ny = (pointer.y / Math.max(window.innerHeight,1) - 0.5) * 2;

  // target offsets influenced by pointer
  state.ox = lerp(state.ox || 0, nx, Math.min(1, 6*dt));
  state.oy = lerp(state.oy || 0, ny, Math.min(1, 6*dt));

  // draw forest to offscreen
  offCtx.clearRect(0,0,off.width,off.height);
  drawForest(offCtx, off.width, off.height, state);

  // upscale to main canvas (pixelated)
  ctx.clearRect(0,0,canvas.width/DPR, canvas.height/DPR);
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(off, 0, 0, off.width, off.height, 0, 0, canvas.width/DPR, canvas.height/DPR);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* menu interaction: press anywhere to continue */
function continueAction(){ if(!menu.classList.contains('hidden')) menu.classList.add('hidden'); }
window.addEventListener('pointerdown', continueAction, {passive:true});
window.addEventListener('touchstart', continueAction, {passive:true});

/* expose pointer for debugging */
window._pixelForestPointer = pointer;
</script>
</body>
</html>
```
