<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Arena — Single File</title>
<style>
  :root{--bg:#071428;--panel:#0b1220;--accent:#7c3aed;--muted:#94a3b8;}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;}
  body{background:linear-gradient(180deg,#071428,#041022);color:#e6eef8;display:flex;gap:16px;padding:18px;box-sizing:border-box;}
  .panel{width:320px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:14px;border-radius:12px;box-shadow:0 10px 40px rgba(2,6,23,.6);}
  h3{margin:6px 0 12px 0;font-size:16px;}
  .row{display:flex;gap:8px;align-items:center;margin-bottom:10px;}
  label{font-size:13px;color:var(--muted);width:88px;}
  input[type=color]{width:62px;height:36px;border:none;background:none;padding:0;cursor:pointer;}
  .preset-row{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap;}
  button{background:var(--accent);border:none;color:white;padding:8px 10px;border-radius:8px;cursor:pointer;}
  .ability-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:8px;}
  .slot{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;text-align:center;font-weight:700;position:relative;}
  .slot small{display:block;font-weight:400;color:var(--muted);font-size:12px;margin-top:4px;}
  .cool{position:absolute;left:6px;right:6px;bottom:6px;height:6px;background:rgba(0,0,0,0.3);border-radius:6px;overflow:hidden;}
  .cool > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#f97316);width:0%;}
  .hint{color:var(--muted);font-size:13px;margin-top:10px;}
  .footer{color:var(--muted);font-size:13px;margin-top:12px;}
  .scene-wrap{flex:1;display:flex;flex-direction:column;gap:8px;}
  canvas{width:100%;height:calc(100vh - 56px);border-radius:12px;display:block;background:#061026;}
  .hud-top{display:flex;gap:8px;align-items:center;padding:6px;color:var(--muted);}
  .hp{width:200px;height:12px;background:#142032;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.03);}
  .hp > i{display:block;height:100%;background:linear-gradient(90deg,#ef4444,#f97316);width:100%;}
  .controls{color:var(--muted);font-size:13px;margin-left:auto;}
  .small{background:#123;padding:6px 8px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);cursor:pointer;}
  .footer-right{display:flex;gap:8px;align-items:center;}
  .center-note{position:absolute;left:50%;transform:translateX(-50%);bottom:16px;color:rgba(255,255,255,0.7);font-size:13px;pointer-events:none;}
  /* compact mobile */
  @media (max-width:900px){body{flex-direction:column;} .panel{width:100%;order:2} canvas{height:60vh}}
</style>
</head>
<body>
  <aside class="panel">
    <h3>Customize Character</h3>
    <div class="row">
      <label>Body</label><input id="bodyColor" type="color" value="#ff6b6b">
    </div>
    <div class="row">
      <label>Hair</label><input id="hairColor" type="color" value="#222222">
    </div>
    <div class="row">
      <label>Eyes</label><input id="eyeColor" type="color" value="#111111">
    </div>
    <div class="preset-row">
      <button id="preset1">Spiky</button><button id="preset2">Curtains</button><button id="preset3">Mohawk</button>
    </div>

    <h3 style="margin-top:14px">Abilities (1–4)</h3>
    <div class="ability-grid">
      <div class="slot" id="slot1">1<small>Fireball</small><div class="cool"><i id="c1"></i></div></div>
      <div class="slot" id="slot2">2<small>Shockwave</small><div class="cool"><i id="c2"></i></div></div>
      <div class="slot" id="slot3">3<small>Dash</small><div class="cool"><i id="c3"></i></div></div>
      <div class="slot" id="slot4">4<small>Beam</small><div class="cool"><i id="c4"></i></div></div>
    </div>
    <div class="hint">Use WASD to move • Mouse to aim • Press 1-4 to use abilities • R to respawn</div>

    <div class="footer">
      <div style="margin-top:10px;display:flex;gap:8px;">
        <button id="spawnBtn">Spawn +3 Dummies</button>
        <button id="resetBtn" class="small">Reset</button>
      </div>
      <div style="margin-top:10px;">
        <div style="font-size:13px;color:var(--muted)">Deploy: single-file, ready for Vercel</div>
      </div>
    </div>
  </aside>

  <section class="scene-wrap">
    <div class="hud-top">
      <div class="hp"><i id="hpFill" style="width:100%"></i></div>
      <div id="status" style="margin-left:8px">Ready</div>
      <div class="controls">Dummies: <span id="dummyCount">0</span></div>
      <div style="flex:1"></div>
      <div class="footer-right"><button id="downloadConfig" class="small">Copy Config</button></div>
    </div>
    <canvas id="c"></canvas>
    <div class="center-note">Pixel Arena — press 1–4 to fire abilities</div>
  </section>

<script src="https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.min.js"></script>
<script>
/* =========================
   Single-file Pixel Arena
   - blocky 3D player, stadium, dummies
   - customizer: body/hair/eyes
   - 4 ability slots (1: projectile, 2: aoe, 3: dash, 4: short beam)
   - WASD movement, mouse aim
   - minimal visual feedback: particles, cooldown bars, floating damage
   ========================= */

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:false, alpha:false});
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth - 380, Math.max(window.innerHeight - 120, 420));
renderer.setClearColor(0x061026, 1);
window.addEventListener('resize', ()=> {
  renderer.setSize(window.innerWidth - 380, Math.max(window.innerHeight - 120, 420));
  camera.aspect = (window.innerWidth - 380) / Math.max(window.innerHeight - 120, 420);
  camera.updateProjectionMatrix();
});

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, (window.innerWidth - 380) / Math.max(window.innerHeight - 120, 420), 0.1, 100);
camera.position.set(0, 8, 10);
camera.lookAt(0,0,0);

const ambient = new THREE.AmbientLight(0xffffff, 0.7);
scene.add(ambient);
const dir = new THREE.DirectionalLight(0xffffff, 0.6);
dir.position.set(5,10,3); scene.add(dir);

/* helper: nearest-pixel material look */
function pixelMaterial(hex){
  return new THREE.MeshStandardMaterial({color:hex, roughness:0.7, metalness:0.0});
}

/* stadium ground (blocky tiled look using simple boxes) */
const ground = new THREE.Mesh(new THREE.PlaneGeometry(40,40), new THREE.MeshStandardMaterial({color:0x072034}));
ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

/* stadium ring */
const ringGeo = new THREE.RingGeometry(6.5, 8, 64);
const ringMat = new THREE.MeshStandardMaterial({color:0x0b2740, side: THREE.DoubleSide});
const ring = new THREE.Mesh(ringGeo, ringMat);
ring.rotation.x = -Math.PI/2; ring.position.y = 0.01; scene.add(ring);

/* Pixel-style player (group of boxes) */
const player = {pos:new THREE.Vector3(0,0.9,0), rot:0, hp:100, maxHp:100, cfg:{body:'#ff6b6b', hair:'#222222', eyes:'#111111'}};
const playerGroup = new THREE.Group();
scene.add(playerGroup);

function buildPlayer(){
  playerGroup.clear();
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.9,1.2,0.6), pixelMaterial(player.cfg.body));
  body.position.set(0,0.6,0); playerGroup.add(body);
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.9,0.7,0.6), pixelMaterial(player.cfg.body));
  head.position.set(0,1.1,0); playerGroup.add(head);
  const hair = new THREE.Mesh(new THREE.BoxGeometry(0.98,0.36,0.62), pixelMaterial(player.cfg.hair));
  hair.position.set(0,1.28,0); playerGroup.add(hair);
  const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.18,0.12,0.01), new THREE.MeshBasicMaterial({color:player.cfg.eyes}));
  eyeL.position.set(-0.18,1.08,0.31); playerGroup.add(eyeL);
  const eyeR = eyeL.clone(); eyeR.position.x = 0.18; playerGroup.add(eyeR);
  playerGroup.position.copy(player.pos);
}

/* dummy template */
const dummies = []; // {mesh, hp, id}
function spawnDummy(x,z){
  const g = new THREE.BoxGeometry(0.6,0.9,0.4);
  const m = pixelMaterial(0xbfc7d6);
  const mesh = new THREE.Mesh(g,m);
  mesh.position.set(x,0.45,z);
  scene.add(mesh);
  const id = Math.floor(Math.random()*1000000);
  dummies.push({id,mesh,hp:40,maxHp:40,vel:new THREE.Vector3()});
  updateDummyCount();
}
function spawnMany(n=3){
  for(let i=0;i<n;i++){
    const a = Math.random()*Math.PI*2;
    const r = 2 + Math.random()*4;
    spawnDummy(Math.cos(a)*r, Math.sin(a)*r);
  }
}

/* projectiles and effects */
const projectiles = []; // {mesh, vel, life, dmg, owner}
const aos = []; // aoe visuals {mesh, life, radius}

/* simple particle pool (squares) */
const particles = [];
function spawnParticle(pos, color=0xffc58b, count=8){
  for(let i=0;i<count;i++){
    const geom = new THREE.PlaneGeometry(0.12,0.12);
    const mat = new THREE.MeshBasicMaterial({color,transparent:true});
    const m = new THREE.Mesh(geom, mat);
    m.position.copy(pos);
    m.position.y += 0.5 + Math.random()*0.2;
    m.rotation.x = -Math.PI/2;
    scene.add(m);
    particles.push({mesh:m, vel:new THREE.Vector3((Math.random()-0.5)*1.5, Math.random()*1.2, (Math.random()-0.5)*1.5), life:0.6});
  }
}

/* abilities config and cooldown tracking */
const ABILITIES = {
  1: {id:1,name:'Fireball',type:'projectile',cool:600,damage:16,speed:8,radius:0.12},
  2: {id:2,name:'Shockwave',type:'aoe',cool:1400,damage:12,radius:2.0,duration:0.5},
  3: {id:3,name:'Dash',type:'dash',cool:1000,damage:8,speed:12},
  4: {id:4,name:'Beam',type:'beam',cool:1800,damage:3,duration:600} // ms duration short beam
};
const cdState = {1:0,2:0,3:0,4:0};
const cEls = {1:document.getElementById('c1'),2:document.getElementById('c2'),3:document.getElementById('c3'),4:document.getElementById('c4')};

/* input and movement */
const keys = {};
window.addEventListener('keydown', (e)=>{ keys[e.key.toLowerCase()] = true; if(['1','2','3','4'].includes(e.key)){ useAbility(Number(e.key)); }});
window.addEventListener('keyup', (e)=>{ keys[e.key.toLowerCase()] = false; });
let mouse = {x:0,y:0,down:false,screenX:0,screenY:0};
canvas.addEventListener('mousemove', (e)=>{ mouse.screenX = e.clientX; mouse.screenY = e.clientY; });
canvas.addEventListener('mousedown', ()=> mouse.down = true);
canvas.addEventListener('mouseup', ()=> mouse.down = false);

/* ability use logic */
function useAbility(slot){
  const now = performance.now();
  const ab = ABILITIES[slot];
  if(!ab) return;
  if(now < cdState[slot]) { setStatus('On cooldown'); return; }
  cdState[slot] = now + ab.cool;
  updateCooldownVisual(slot);
  if(ab.type === 'projectile'){
    // spawn sphere projectile from player forward
    const dir = aimDirection();
    const geom = new THREE.SphereGeometry(ab.radius,8,8);
    const mat = new THREE.MeshStandardMaterial({color:0xffb86b});
    const mesh = new THREE.Mesh(geom, mat);
    const pos = new THREE.Vector3().copy(player.pos).add(new THREE.Vector3(dir.x,0.6,dir.z).multiplyScalar(0.8));
    mesh.position.copy(pos);
    scene.add(mesh);
    projectiles.push({mesh, vel: new THREE.Vector3(dir.x*ab.speed, 0, dir.z*ab.speed), life:3, dmg:ab.damage});
    spawnParticle(pos, 0xffb86b, 6);
    setStatus('Fired Fireball');
  } else if(ab.type === 'aoe'){
    // aoe around player
    const geom = new THREE.CircleGeometry(ab.radius, 32);
    const mat = new THREE.MeshBasicMaterial({color:0x7c3aed, transparent:true, opacity:0.16, side:THREE.DoubleSide});
    const mesh = new THREE.Mesh(geom, mat);
    mesh.rotation.x = -Math.PI/2; mesh.position.copy(player.pos); mesh.position.y = 0.02;
    scene.add(mesh);
    aos.push({mesh, life:ab.duration, radius:ab.radius, dmg:ab.damage});
    // apply instantly
    for(const d of dummies){ const dist = d.mesh.position.distanceTo(player.pos); if(dist <= ab.radius+0.6){ hitDummy(d, ab.damage, new THREE.Vector3().subVectors(d.mesh.position, player.pos).normalize()); } }
    spawnParticle(player.pos, 0x7c3aed, 12);
    setStatus('Shockwave');
  } else if(ab.type === 'dash'){
    // dash: impulse in aim direction and hit dummies in path
    const dir = aimDirection();
    const dashVel = new THREE.Vector3(dir.x * ab.speed, 0, dir.z * ab.speed);
    player.pos.add(dashVel.clone().multiplyScalar(0.12));
    // tiny push dummies near
    for(const d of dummies){ if(d.mesh.position.distanceTo(player.pos) < 1.2){ hitDummy(d, ab.damage, dashVel.clone().normalize()); } }
    spawnParticle(player.pos, 0xffffff, 8);
    setStatus('Dashed');
  } else if(ab.type === 'beam'){
    // short timed beam: run sweep and spawn visual
    const dir = aimDirection();
    const beamId = Date.now();
    const beamGeom = new THREE.CylinderGeometry(0.05,0.05,8,6);
    const beamMat = new THREE.MeshBasicMaterial({color:0x88ffea, transparent:true, opacity:0.85});
    const beam = new THREE.Mesh(beamGeom, beamMat);
    beam.rotation.x = Math.PI/2;
    beam.position.copy(player.pos).add(new THREE.Vector3(dir.x*4,0.6,dir.z*4));
    scene.add(beam);
    setTimeout(()=> { scene.remove(beam); }, ab.duration);
    // continuous short damage in front instantly
    for(const d of dummies){
      const toD = new THREE.Vector3().subVectors(d.mesh.position, player.pos);
      const forward = new THREE.Vector3(dir.x,0,dir.z);
      if(toD.dot(forward) > 0 && toD.length() < 5){
        hitDummy(d, ab.damage*2, forward);
      }
    }
    spawnParticle(player.pos.clone().add(new THREE.Vector3(dir.x*1.2,0,dir.z*1.2)), 0x88ffea, 10);
    setStatus('Beam');
  }
}

/* aim direction from camera to mouse onto ground plane */
function aimDirection(){
  // convert mouse into -1..1 NDC
  const rect = renderer.domElement.getBoundingClientRect();
  const ndcX = ((mouse.screenX - rect.left) / rect.width) * 2 - 1;
  const ndcY = -((mouse.screenY - rect.top) / rect.height) * 2 + 1;
  const v = new THREE.Vector3(ndcX, ndcY, 0.5).unproject(camera);
  const dir = new THREE.Vector3().subVectors(v, camera.position).normalize();
  // intersect with y=0 plane
  const t = (0 - camera.position.y) / dir.y;
  const intersect = new THREE.Vector3().copy(camera.position).add(dir.multiplyScalar(t));
  const forward = new THREE.Vector3().subVectors(intersect, player.pos);
  forward.y = 0;
  forward.normalize();
  return forward;
}

/* hit computation */
function hitDummy(d, dmg, pushDir){
  if(d.hp <= 0) return;
  d.hp -= dmg;
  spawnParticle(d.mesh.position, 0xffc0c0, 6);
  // tiny knockback
  d.vel.add(pushDir.clone().multiplyScalar(1.6));
  // floating damage: quickly show title using DOM
  showFloatingText(d.mesh.position.clone(), `-${Math.floor(dmg)}`, 0xffe6e6);
  if(d.hp <= 0){
    // die: fall over (rotate and lower)
    d.mesh.userData.dead = true;
    setTimeout(()=>{ // respawn after 2s
      scene.remove(d.mesh);
      const idx = dummies.findIndex(x=>x.id===d.id);
      if(idx !== -1) dummies.splice(idx,1);
      updateDummyCount();
      setTimeout(()=> spawnMany(1), 1200);
    }, 800);
  }
}

/* floating damage text using simple DOM overlay */
const floatingRoot = document.createElement('div');
floatingRoot.style.position = 'absolute'; floatingRoot.style.left = '0'; floatingRoot.style.top = '0'; floatingRoot.style.pointerEvents='none';
document.body.appendChild(floatingRoot);
function showFloatingText(worldPos, text, color){
  // project to screen
  const v = worldPos.clone();
  v.project(camera);
  const x = (v.x * 0.5 + 0.5) * window.innerWidth;
  const y = (-v.y * 0.5 + 0.5) * window.innerHeight;
  const el = document.createElement('div');
  el.textContent = text; el.style.position='absolute'; el.style.left = x + 'px'; el.style.top = y + 'px'; el.style.transform='translate(-50%,-50%)';
  el.style.color = '#' + color.toString(16).padStart(6,'0'); el.style.fontWeight = '800'; el.style.fontFamily='monospace';
  el.style.opacity = '1'; el.style.transition='transform 900ms ease-out, opacity 900ms';
  floatingRoot.appendChild(el);
  requestAnimationFrame(()=> {
    el.style.transform = 'translate(-50%,-140%) scale(0.95)';
    el.style.opacity = '0';
  });
  setTimeout(()=> floatingRoot.removeChild(el), 900);
}

/* update cooldown bars visually */
function updateCooldownVisual(slot){
  const el = cEls[slot];
  if(!el) return;
  const total = ABILITIES[slot].cool;
  const then = performance.now();
  function tick(){
    const rem = Math.max(0, cdState[slot] - performance.now());
    const p = 1 - rem / total;
    el.style.width = (p*100) + '%';
    if(rem > 0) requestAnimationFrame(tick);
    else { el.style.width = '100%'; setTimeout(()=> el.style.width='0%',50); }
  }
  requestAnimationFrame(tick);
}

/* update dummy counter */
function updateDummyCount(){ document.getElementById('dummyCount').textContent = dummies.length; }

/* status text */
const statusEl = document.getElementById('status');
let statusTimer = 0;
function setStatus(t){
  statusEl.textContent = t;
  statusTimer = performance.now() + 1200;
}

/* spawn initial dummies */
spawnMany(6);

/* build player and initial UI */
buildPlayer();
document.getElementById('bodyColor').addEventListener('input', (e)=>{ player.cfg.body = e.target.value; buildPlayer(); });
document.getElementById('hairColor').addEventListener('input', (e)=>{ player.cfg.hair = e.target.value; buildPlayer(); });
document.getElementById('eyeColor').addEventListener('input', (e)=>{ player.cfg.eyes = e.target.value; buildPlayer(); });
document.getElementById('preset1').addEventListener('click', ()=>{ document.getElementById('hairColor').value='#2d2b2b'; document.getElementById('bodyColor').value='#ff6b6b'; document.getElementById('eyeColor').value='#111111'; player.cfg = {body:'#ff6b6b', hair:'#2d2b2b', eyes:'#111111'}; buildPlayer();});
document.getElementById('preset2').addEventListener('click', ()=>{ document.getElementById('hairColor').value='#4b5563'; document.getElementById('bodyColor').value='#60a5fa'; document.getElementById('eyeColor').value='#0b1220'; player.cfg={body:'#60a5fa',hair:'#4b5563',eyes:'#0b1220'}; buildPlayer();});
document.getElementById('preset3').addEventListener('click', ()=>{ document.getElementById('hairColor').value='#ffcd4a'; document.getElementById('bodyColor').value='#34d399'; document.getElementById('eyeColor').value='#0b1220'; player.cfg={body:'#34d399',hair:'#ffcd4a',eyes:'#0b1220'}; buildPlayer();});

document.getElementById('spawnBtn').addEventListener('click', ()=>{ spawnMany(3); updateDummyCount(); });
document.getElementById('resetBtn').addEventListener('click', ()=>{ for(const d of dummies){ scene.remove(d.mesh);} dummies.length=0; spawnMany(5); updateDummyCount();});

/* copy config */
document.getElementById('downloadConfig').addEventListener('click', ()=> {
  const cfg = {body:player.cfg.body, hair:player.cfg.hair, eyes:player.cfg.eyes};
  navigator.clipboard?.writeText(JSON.stringify(cfg, null, 2)).then(()=> setStatus('Config copied'));
});

/* simple physics + game loop */
let last = performance.now();
function animate(){
  const now = performance.now();
  const dt = Math.min(0.035, (now - last)/1000);
  last = now;

  // player movement WASD
  const speed = 4.0;
  const mv = new THREE.Vector3();
  if(keys['w'] || keys['arrowup']) mv.z -= 1;
  if(keys['s'] || keys['arrowdown']) mv.z += 1;
  if(keys['a'] || keys['arrowleft']) mv.x -= 1;
  if(keys['d'] || keys['arrowright']) mv.x += 1;
  if(mv.lengthSq() > 0){ mv.normalize(); player.pos.add(mv.multiplyScalar(speed*dt)); }
  // clamp within ring
  const r = Math.hypot(player.pos.x, player.pos.z);
  if(r > 7.6){ player.pos.multiplyScalar(7.6 / r); }

  // update player group pos and rotate to aim
  const aim = aimDirection();
  playerGroup.position.copy(player.pos);
  const yaw = Math.atan2(aim.x, -aim.z);
  playerGroup.rotation.y = yaw + Math.PI;
  // update hp bar
  document.getElementById('hpFill').style.width = Math.max(0, (player.hp/player.maxHp)*100) + '%';

  // update projectiles
  for(let i = projectiles.length-1; i>=0; i--){
    const p = projectiles[i];
    p.life -= dt;
    p.mesh.position.addScaledVector(p.vel, dt);
    // check collisions with dummies
    for(const d of dummies){
      if(d.hp <= 0) continue;
      const dist = d.mesh.position.distanceTo(p.mesh.position);
      if(dist < 0.6){
        hitDummy(d, p.dmg, p.vel.clone().normalize());
        // remove projectile
        scene.remove(p.mesh);
        projectiles.splice(i,1);
        spawnParticle(p.mesh.position, 0xffc0a0, 6);
        break;
      }
    }
    if(p && p.life <= 0){ scene.remove(p.mesh); const idx = projectiles.indexOf(p); if(idx!==-1) projectiles.splice(idx,1); }
  }

  // update aos
  for(let i=aos.length-1;i>=0;i--){
    const a = aos[i]; a.life -= dt;
    a.mesh.material.opacity = Math.max(0, a.life / 0.5) * 0.16;
    if(a.life <= 0){ scene.remove(a.mesh); aos.splice(i,1); }
  }

  // update dummies: simple wander + apply vel
  for(const d of dummies){
    if(d.mesh.userData.dead) continue;
    if(Math.random() < 0.008) d.vel.add(new THREE.Vector3((Math.random()-0.5)*0.6,0,(Math.random()-0.5)*0.6));
    d.mesh.position.addScaledVector(d.vel, dt);
    d.vel.multiplyScalar(0.85);
    // clamp inside ring
    const r2 = Math.hypot(d.mesh.position.x, d.mesh.position.z);
    if(r2 > 8.5){ d.mesh.position.multiplyScalar(8.5 / r2); }
    // simple regen if damaged
    if(d.hp < d.maxHp && Math.random() < 0.002){ d.hp += 0.2; }
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i]; p.life -= dt;
    p.mesh.position.addScaledVector(p.vel, dt);
    p.mesh.material.opacity = Math.max(0, p.life/0.6);
    if(p.life <= 0){ scene.remove(p.mesh); particles.splice(i,1); }
  }

  // status fade
  if(statusTimer && performance.now() > statusTimer){ statusTimer = 0; statusEl.textContent = 'Ready'; }

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* utility: spawn initial projectiles when clicking mouse (optional) */
canvas.addEventListener('click', ()=> {
  // also fire primary (slot 1) on click for convenience
  useAbility(1);
});

/* simple on-screen cooldown updater (fills then empties) */
function refreshCooldowns(){
  const now = performance.now();
  for(let s=1;s<=4;s++){
    const el = cEls[s];
    const ab = ABILITIES[s];
    const remaining = Math.max(0, cdState[s] - now);
    const pct = 1 - (remaining / ab.cool);
    el.style.width = (pct*100) + '%';
  }
  requestAnimationFrame(refreshCooldowns);
}
requestAnimationFrame(refreshCooldowns);

/* respawn helper */
window.addEventListener('keydown', (e)=> { if(e.key.toLowerCase() === 'r'){ for(const d of dummies){ scene.remove(d.mesh);} dummies.length=0; spawnMany(5); updateDummyCount(); setStatus('Respawned'); } });

/* tiny UI updates initial */
updateDummyCount();
setStatus('Ready. Press 1-4 to use abilities.');

/* expose spawnMany to console for quick testing */
window._spawnMany = spawnMany;
</script>
</body>
</html>
