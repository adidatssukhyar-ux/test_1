<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pick Your Power â€” Pixel Forest (Fixed)</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root{--bg:#071022;--accent:#ffd88a;--muted:#b6c7d9;}
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Roboto,Arial;-webkit-font-smoothing:antialiased;}
  #app{position:relative;height:100vh;overflow:hidden;display:flex;align-items:center;justify-content:center;}
  canvas{display:block;width:100%;height:100%;image-rendering:pixelated;}
  .menu{position:absolute; left:50%; top:46%; transform:translate(-50%,-50%); text-align:center; color:var(--accent); text-shadow:0 12px 40px rgba(0,0,0,0.75); pointer-events:none; z-index:5;}
  .title{font-family:'Press Start 2P',monospace; font-size:40px; letter-spacing:2px; margin:0; color:var(--accent);}
  .prompt{margin-top:14px; font-family:'Press Start 2P',monospace; font-size:12px; color:var(--muted); letter-spacing:1px;}
  .menu.hidden{opacity:0; transform:translate(-50%,-56%) scale(.98); transition:opacity 260ms, transform 260ms;}
  .hint-bar{position:absolute;left:50%;transform:translateX(-50%);bottom:28px;padding:8px 14px;border-radius:10px;background:rgba(0,0,0,0.28);color:rgba(255,255,255,0.95);font-family:'Press Start 2P',monospace;font-size:11px;z-index:4;display:none}
  .hint-bar.visible{display:block}
  @media (max-width:760px){ .title{font-size:20px} .prompt{font-size:10px} }
</style>
</head>
<body>
  <div id="app" role="main" aria-label="Pick Your Power intro">
    <canvas id="bg"></canvas>
    <div class="menu" id="menu" aria-hidden="false">
      <div class="title">PICK YOUR POWER!</div>
      <div class="prompt">PRESS ANYWHERE TO CONTINUE</div>
    </div>
    <div class="hint-bar" id="hint">Move your mouse to pan the scene</div>
  </div>

<script>
/* Fixed cinematic pixel forest:
 - Low-res offscreen canvas is drawn and upscaled for crisp pixel look.
 - Visible layered landscape (sky, distant ridges, big central peak, mid & near trees).
 - Smooth mouse follow (X and Y) using smoothed offsets.
 - Menu shows title + "press anywhere"; clicking hides it and shows hint bar briefly.
*/

/* Canvas setup */
const canvas = document.getElementById('bg');
const ctx = canvas.getContext('2d', { alpha: false });
const menu = document.getElementById('menu');
const hint = document.getElementById('hint');

let DPR = Math.min(window.devicePixelRatio || 1, 2);
const off = document.createElement('canvas');
const offCtx = off.getContext('2d', { alpha: false });

let lowW = 640, lowH = 360;
function fit() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  // pick a low-res based on aspect, keep it in a useful range
  const aspect = w / h;
  lowW = Math.max(360, Math.min(900, Math.round(640 * Math.min(1.8, aspect))));
  lowH = Math.round(lowW * 9 / 16);
  off.width = lowW; off.height = lowH;
  canvas.width = lowW * DPR; canvas.height = lowH * DPR;
  canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled = false; offCtx.imageSmoothingEnabled = false;
}
window.addEventListener('resize', fit);
fit();

/* input state */
const pointer = { x: window.innerWidth/2, y: window.innerHeight/2 };
window.addEventListener('mousemove', e => { pointer.x = e.clientX; pointer.y = e.clientY; });
window.addEventListener('touchmove', e => { const t = e.touches[0]; if(t){ pointer.x = t.clientX; pointer.y = t.clientY; } }, {passive:true});

/* smoothing & state */
const state = { time:0, tx:0, ty:0, sx:0, sy:0 };

/* helpers */
function lerp(a,b,t){ return a + (b-a) * t; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

/* Drawing primitives for pixel forest */
function drawSky(c,w,h){
  const g = c.createLinearGradient(0,0,0,h);
  g.addColorStop(0, '#fff3e6'); g.addColorStop(0.18, '#ffdfe8'); g.addColorStop(0.45, '#ffd0ef'); g.addColorStop(1, '#6d98d6');
  c.fillStyle = g; c.fillRect(0,0,w,h);
  // faint long cloud bands
  c.globalAlpha = 0.12;
  c.fillStyle = '#ffffff';
  c.fillRect(0, Math.round(h*0.12), w, Math.round(h*0.06));
  c.fillRect(0, Math.round(h*0.18), w, Math.round(h*0.04));
  c.globalAlpha = 1;
}

function drawRidge(c,w,h,baseY,color,peaks,amp,ox,oy){
  c.save(); c.translate(ox, oy);
  c.fillStyle = color; c.beginPath(); c.moveTo(-40,h);
  for(let i=0;i<=peaks;i++){
    const px = Math.round((i/peaks)*(w+80)-40);
    const noise = Math.sin(i*1.1 + performance.now()*0.00008) * amp;
    const py = Math.round(baseY - Math.abs(Math.cos(i*0.7)) * (80* (amp/6 + 1)) + noise);
    c.lineTo(px,py);
  }
  c.lineTo(w+40,h); c.closePath(); c.fill(); c.restore();
}

function drawCentralPeak(c,w,h,baseY,ox,oy){
  c.save(); c.translate(ox,oy);
  const cx = Math.round(w/2); const peakY = baseY - 220;
  const left = cx - 260, right = cx + 260;
  const grad = c.createLinearGradient(cx, peakY, cx, baseY);
  grad.addColorStop(0, '#2b6094'); grad.addColorStop(1, '#13486f');
  c.fillStyle = grad; c.beginPath(); c.moveTo(cx,peakY); c.lineTo(right,baseY); c.lineTo(left,baseY); c.closePath(); c.fill();
  // snow cap
  c.fillStyle = '#ffffff';
  c.beginPath();
  const capBase = peakY + 72; const capW = 200;
  c.moveTo(cx - capW/2, capBase);
  for(let i=0;i<=10;i++){
    const t = i/10; const x = cx - capW/2 + t*capW;
    const y = capBase - Math.sin(t*Math.PI*2) * 16 * (0.8 + Math.random()*0.4);
    c.lineTo(Math.round(x), Math.round(y));
  }
  c.lineTo(cx + capW/2, capBase); c.lineTo(cx, peakY+12); c.closePath(); c.fill();
  c.restore();
}

function drawTreeBand(c,w,baseY,count,scale,depthX,depthY,ox,oy,blossoms=false){
  c.save();
  // parallax translation driven by offsets
  c.translate(ox * depthX, oy * depthY);
  for(let i=0;i<count;i++){
    const t = i/(count-1);
    const x = Math.round(t * w + Math.sin(state.time*0.6 + i*1.2) * 6 + (Math.random()-0.5)*10);
    const h = Math.round(48 + Math.random()*80 * scale);
    drawBlockTree(c, x, baseY + Math.round((Math.random()-0.5)*8), h, blossoms && Math.random() > 0.5);
  }
  c.restore();
}

function drawBlockTree(c,x,baseY,hgt,blossoms){
  c.save(); c.translate(x, baseY);
  c.fillStyle = '#3a291e'; c.fillRect(-2,0,4, Math.round(hgt*0.26));
  const layers = 4; const baseW = Math.round(hgt*0.78);
  for(let i=0;i<layers;i++){
    const w = Math.max(8, Math.round(baseW - i*(baseW*0.2)));
    const y = -Math.round(hgt*0.14) - i * Math.round(hgt*0.22);
    const shade = i===0 ? '#2f6b42' : shadeRGB('#2f6b42', -6*i);
    c.fillStyle = shade; c.fillRect(-Math.round(w/2), y, w, Math.round(hgt*0.22));
  }
  if(blossoms){
    for(let p=0;p<6;p++){
      const bx = Math.round((Math.random()-0.5)*(baseW*0.6));
      const by = Math.round(-Math.random()*hgt*0.6 - 8);
      c.fillStyle = p%2===0 ? '#ffc6e1' : '#ffdbe9';
      c.fillRect(bx, by, 2, 2);
    }
  }
  c.restore();
}

function shadeRGB(hex, pct){
  const f = hex.replace('#','');
  const R = parseInt(f.substring(0,2),16);
  const G = parseInt(f.substring(2,4),16);
  const B = parseInt(f.substring(4,6),16);
  const t = pct/100;
  const newR = Math.round(R + ((t>0?255:0) - R) * Math.abs(t));
  const newG = Math.round(G + ((t>0?255:0) - G) * Math.abs(t));
  const newB = Math.round(B + ((t>0?255:0) - B) * Math.abs(t));
  return `rgb(${clamp(newR,0,255)},${clamp(newG,0,255)},${clamp(newB,0,255)})`;
}

/* compose full scene on low-res offscreen */
function compose(c,w,h, ox, oy){
  drawSky(c,w,h);
  // distant ridges
  drawRidge(c,w,h, Math.round(h*0.44), '#dbeefc', 10, 8, ox*0.02, oy*0.01);
  drawRidge(c,w,h, Math.round(h*0.56), '#9fc0ea', 10, 12, ox*0.05, oy*0.02);
  drawCentralPeak(c,w,h, Math.round(h*0.68), ox*0.12, oy*0.05);
  // tree bands with increasing parallax
  drawTreeBand(c,w, Math.round(h*0.74), 12, 0.36, 0.28, 0.08, ox, oy, false);
  drawTreeBand(c,w, Math.round(h*0.82), 10, 0.64, 0.6, 0.14, ox, oy, true);
  drawTreeBand(c,w, Math.round(h*0.92), 8, 0.9, 1.0, 0.28, ox, oy, true);
  // foreground rim
  c.fillStyle = '#061226'; c.fillRect(0, Math.round(h*0.94), w, h - Math.round(h*0.94));
  // vignette
  c.globalCompositeOperation = 'multiply';
  const vg = c.createLinearGradient(0,0,0,h);
  vg.addColorStop(0, 'rgba(0,0,0,0)');
  vg.addColorStop(0.6, 'rgba(0,0,0,0.04)');
  vg.addColorStop(1, 'rgba(0,0,0,0.18)');
  c.fillStyle = vg; c.fillRect(0,0,w,h);
  c.globalCompositeOperation = 'source-over';
}

/* animation loop */
let last = performance.now();
function loop(now){
  const dt = Math.min((now - last)/1000, 0.033);
  last = now;
  state.time += dt;

  const nx = (pointer.x / Math.max(window.innerWidth,1) - 0.5) * 2;
  const ny = (pointer.y / Math.max(window.innerHeight,1) - 0.5) * 2;

  state.tx = clamp(nx * 1.0, -1, 1);
  state.ty = clamp(ny * 0.9, -1, 1);

  state.sx = lerp(state.sx || 0, state.tx, Math.min(1, 6*dt));
  state.sy = lerp(state.sy || 0, state.ty, Math.min(1, 6*dt));

  const ox = state.sx; const oy = state.sy;

  // draw offscreen low-res
  offCtx.clearRect(0,0,off.width,off.height);
  compose(offCtx, off.width, off.height, ox, oy);

  // upscale pixelated
  ctx.clearRect(0,0,canvas.width/DPR, canvas.height/DPR);
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(off, 0, 0, off.width, off.height, 0, 0, canvas.width/DPR, canvas.height/DPR);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* menu interaction */
function continueAction(){
  if(!menu.classList.contains('hidden')){
    menu.classList.add('hidden');
    hint.classList.add('visible');
    setTimeout(()=> hint.classList.remove('visible'), 4200);
  }
}
window.addEventListener('pointerdown', continueAction, {passive:true});
window.addEventListener('touchstart', continueAction, {passive:true});

/* expose pointer for debugging */
window._pixelPointer = pointer;

/* initial fit call (ensures off canvas is sized) */
fit();
</script>
</body>
</html>
```
