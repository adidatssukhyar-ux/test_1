<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pick Your Power â€” Starfield Intro</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root{--bg:#030215;--accent:#9be7ff;--muted:#9bb0c8;}
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Roboto,Arial;color:white;-webkit-font-smoothing:antialiased;}
  #app{position:relative;height:100vh;overflow:hidden;display:flex;align-items:center;justify-content:center;}
  canvas{display:block;width:100%;height:100%;background:transparent;}
  .menu{position:absolute;left:50%;top:44%;transform:translate(-50%,-50%);text-align:center;color:var(--accent);text-shadow:0 10px 30px rgba(0,0,0,0.75);pointer-events:none;z-index:4}
  .title{font-family:'Press Start 2P',monospace;font-size:40px;letter-spacing:2px;margin:0;color:var(--accent)}
  .prompt{margin-top:16px;font-family:'Press Start 2P',monospace;font-size:12px;color:var(--muted);letter-spacing:1px}
  .menu.hidden{opacity:0;transform:translate(-50%,-56%) scale(.98);transition:opacity 260ms, transform 260ms}
  .hint{position:absolute;left:50%;transform:translateX(-50%);bottom:24px;padding:6px 12px;border-radius:10px;background:rgba(0,0,0,0.24);color:rgba(255,255,255,0.9);font-family:'Press Start 2P',monospace;font-size:11px;z-index:3;display:none}
  .hint.visible{display:block}
  @media (max-width:760px){ .title{font-size:18px} .prompt{font-size:10px} }
</style>
</head>
<body>
  <div id="app" role="main" aria-label="Pick Your Power star intro">
    <canvas id="bg"></canvas>
    <div class="menu" id="menu" aria-hidden="false">
      <div class="title">PICK YOUR POWER!</div>
      <div class="prompt">PRESS ANYWHERE TO CONTINUE</div>
    </div>
    <div class="hint" id="hint">Move your mouse to pan the cosmos</div>
  </div>

<script>
/*
Single-file starfield intro:
- Offscreen low-res star layers + high-res planets, upscaled for crispness.
- Parallax follows mouse (x,y) with smooth easing.
- Title + "press anywhere" menu. Click hides menu and shows hint for a few seconds.
- No external assets required. All procedural.
*/

const canvas = document.getElementById('bg');
const ctx = canvas.getContext('2d', { alpha: true });
const menu = document.getElementById('menu');
const hint = document.getElementById('hint');

let DPR = Math.min(window.devicePixelRatio || 1, 2);

// Offscreen low-res surface for starfield layering (pixelated/star density control)
const off = document.createElement('canvas');
const offCtx = off.getContext('2d', { alpha: true });

let lowW = 640, lowH = 360;
function fit() {
  const w = window.innerWidth, h = window.innerHeight;
  const aspect = w / h;
  lowW = Math.max(320, Math.min(1200, Math.round(640 * Math.min(1.8, aspect))));
  lowH = Math.round(lowW * 9 / 16);
  off.width = lowW; off.height = lowH;
  canvas.width = lowW * DPR; canvas.height = lowH * DPR;
  canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled = true;
  offCtx.imageSmoothingEnabled = true;
}
window.addEventListener('resize', fit);
fit();

/* pointer + smoothing */
const pointer = { x: window.innerWidth/2, y: window.innerHeight/2, active:false };
window.addEventListener('mousemove', e => { pointer.x = e.clientX; pointer.y = e.clientY; pointer.active = true; });
window.addEventListener('touchmove', e => { const t = e.touches[0]; if(t){ pointer.x = t.clientX; pointer.y = t.clientY; pointer.active = true; } }, {passive:true});

const state = { time:0, tx:0, ty:0, sx:0, sy:0 };

/* helpers */
function lerp(a,b,t){ return a + (b-a) * t; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rand(min,max){ return min + Math.random()*(max-min); }

/* Pre-generate star layers for depth (sparks) */
const STAR_LAYERS = [
  { count: 220, size: 0.7, speed: 0.02, alpha: 0.9, color: '#fff7f3' },
  { count: 140, size: 1.4, speed: 0.04, alpha: 0.85, color: '#cfeaff' },
  { count: 80,  size: 2.4, speed: 0.08, alpha: 0.95, color: '#ffd7ff' }
];

function makeStars(layer){
  const arr = [];
  for(let i=0;i<layer.count;i++){
    arr.push({
      x: Math.random() * lowW,
      y: Math.random() * lowH,
      r: layer.size * (0.6 + Math.random()*0.8),
      tw: Math.random()*1.5 + 0.5,
      phase: Math.random()*Math.PI*2
    });
  }
  return arr;
}
for(const L of STAR_LAYERS) L.stars = makeStars(L);

/* Planets (procedural circles with rings) */
const planets = [
  { x: 0.18, y: 0.22, r: 0.14, colorA:'#ff8a65', colorB:'#ce4a1f', ring:true, ringColor:'rgba(255,200,140,0.12)', speed: 0.01 },
  { x: 0.78, y: 0.36, r: 0.22, colorA:'#6ad3ff', colorB:'#0277bd', ring:false, speed: -0.006 },
  { x: 0.62, y: 0.72, r: 0.10, colorA:'#b19cff', colorB:'#6b3fa0', ring:true, ringColor:'rgba(180,140,255,0.12)', speed: 0.016 }
];

/* Nebula/gradient painter */
function drawNebula(c,w,h, ox, oy, t){
  const g = c.createLinearGradient(0,0,w,h);
  g.addColorStop(0, '#04102b');
  g.addColorStop(0.25, '#06264a');
  g.addColorStop(0.5, '#0b2340');
  g.addColorStop(1, '#00081a');
  c.fillStyle = g; c.fillRect(0,0,w,h);

  // soft moving nebula blobs
  c.globalCompositeOperation = 'lighter';
  for(let i=0;i<5;i++){
    const bx = (Math.sin(t*0.2 + i*1.7) * 0.5 + 0.5) * w + ox * (i-2) * 40;
    const by = (Math.cos(t*0.13 + i*2.3) * 0.5 + 0.5) * h * 0.6 + oy * (i-2) * 24;
    const rad = (0.15 + (i*0.06)) * Math.min(w,h);
    const grad = c.createRadialGradient(bx,by,rad*0.12,bx,by,rad);
    const col = i%2===0 ? 'rgba(120,200,255,0.08)' : 'rgba(220,140,255,0.06)';
    grad.addColorStop(0, col); grad.addColorStop(1, 'rgba(0,0,0,0)');
    c.fillStyle = grad; c.fillRect(bx-rad, by-rad, rad*2, rad*2);
  }
  c.globalCompositeOperation = 'source-over';
}

/* draw stars per-layer (twinkle + parallax) */
function drawStars(c, w, h, ox, oy, t){
  for(let li=0; li<STAR_LAYERS.length; li++){
    const L = STAR_LAYERS[li];
    c.globalAlpha = L.alpha;
    c.fillStyle = L.color;
    for(const s of L.stars){
      // parallax offset scales with layer index
      const px = s.x + ox * (li+1) * 12;
      const py = s.y + oy * (li+1) * 8;
      const tw = 0.6 + Math.sin(t * (s.tw*1.2) + s.phase) * 0.4;
      c.beginPath();
      c.arc(px, py, Math.max(0.3, s.r * tw), 0, Math.PI*2);
      c.fill();
    }
    c.globalAlpha = 1;
  }
}

/* draw planets */
function drawPlanets(c,w,h,t, ox, oy){
  for(let p of planets){
    // move planets slowly for life
    const cx = p.x * w + Math.sin(t * p.speed * 40) * 14 + ox * 80 * (p.r);
    const cy = p.y * h + Math.cos(t * p.speed * 30) * 10 + oy * 40 * (p.r);
    const radius = p.r * Math.min(w,h);
    // body gradient
    const g = c.createRadialGradient(cx - radius*0.3, cy - radius*0.3, radius*0.1, cx, cy, radius);
    g.addColorStop(0, p.colorA); g.addColorStop(1, p.colorB);
    c.fillStyle = g; c.beginPath(); c.arc(cx, cy, radius, 0, Math.PI*2); c.fill();
    // subtle surface shading
    c.fillStyle = 'rgba(0,0,0,0.12)';
    c.beginPath(); c.arc(cx + radius*0.28, cy + radius*0.22, radius*0.9, 0, Math.PI*2); c.fill();
    // ring
    if(p.ring){
      c.save();
      c.translate(cx, cy);
      c.rotate(Math.sin(t * p.speed * 40) * 0.18);
      c.strokeStyle = p.ringColor; c.lineWidth = Math.max(1, radius*0.08);
      c.beginPath(); c.ellipse(0, 0, radius*1.6, radius*0.6, 0, 0, Math.PI*2); c.stroke();
      c.restore();
    }
    // glow
    const glow = c.createRadialGradient(cx,cy,radius*0.3,cx,cy,radius*2.2);
    glow.addColorStop(0,'rgba(255,255,255,0.05)'); glow.addColorStop(1,'rgba(0,0,0,0)');
    c.fillStyle = glow; c.fillRect(cx - radius*2.2, cy - radius*2.2, radius*4.4, radius*4.4);
  }
}

/* small shooting stars and flares */
const meteors = [];
function spawnMeteor(w,h){
  meteors.push({
    x: Math.random()*w,
    y: Math.random()*h*0.35,
    vx: rand(200,420),
    vy: rand(40,140),
    life: rand(800,1700),
    t: 0
  });
}
function updateMeteors(c, w, h, dt, ox, oy){
  for(let i=meteors.length-1;i>=0;i--){
    const m = meteors[i];
    m.t += dt*1000;
    m.x += (m.vx * dt);
    m.y += (m.vy * dt);
    const px = m.x + ox * 30;
    const py = m.y + oy * 12;
    const len = Math.max(8, (m.vx*0.02));
    c.strokeStyle = 'rgba(255,255,255,0.9)';
    c.lineWidth = 1;
    c.beginPath(); c.moveTo(px,py); c.lineTo(px - len, py - len*0.3); c.stroke();
    if(m.t > m.life) meteors.splice(i,1);
  }
  if(Math.random() < 0.004) spawnMeteor(w,h);
}

/* draw faint grid / star-scape depth (optional subtle parallax details) */
function drawGrid(c,w,h, ox, oy){
  c.save();
  c.globalAlpha = 0.06;
  c.strokeStyle = '#88a3c8';
  c.lineWidth = 1;
  const spacing = Math.round(Math.min(w,h) * 0.12);
  for(let x = -spacing*2; x < w+spacing*2; x += spacing){
    c.beginPath(); c.moveTo(x + ox*30, 0); c.lineTo(x + ox*30, h); c.stroke();
  }
  c.globalAlpha = 1; c.restore();
}

/* main draw loop */
let last = performance.now();
function loop(now){
  const dt = Math.min((now - last)/1000, 0.033);
  last = now;
  state.time += dt;

  // pointer normalized -1..1
  const nx = (pointer.x / Math.max(window.innerWidth,1) - 0.5) * 2;
  const ny = (pointer.y / Math.max(window.innerHeight,1) - 0.5) * 2;

  // targets for smooth parallax
  state.tx = clamp(nx * 1.0, -1, 1);
  state.ty = clamp(ny * 0.9, -1, 1);

  state.sx = lerp(state.sx || 0, state.tx, Math.min(1, 6*dt));
  state.sy = lerp(state.sy || 0, state.ty, Math.min(1, 6*dt));

  // map to pixel-space offsets for layers
  const ox = state.sx; const oy = state.sy;

  // draw nebula & base to offscreen
  offCtx.clearRect(0,0,off.width, off.height);
  drawNebula(offCtx, off.width, off.height, ox, oy, state.time);

  // stars (layers)
  drawStars(offCtx, off.width, off.height, ox, oy, state.time);

  // planets (draw above stars)
  drawPlanets(offCtx, off.width, off.height, state.time, ox, oy);

  // meteors
  updateMeteors(offCtx, off.width, off.height, dt, ox, oy);

  // upscale offscreen to visible canvas with slight smoothing for glow
  ctx.clearRect(0,0,canvas.width/DPR, canvas.height/DPR);
  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(off, 0, 0, off.width, off.height, 0, 0, canvas.width/DPR, canvas.height/DPR);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* menu interaction */
function continueAction(){
  if(!menu.classList.contains('hidden')){
    menu.classList.add('hidden');
    hint.classList.add('visible');
    setTimeout(()=> hint.classList.remove('visible'), 4200);
  }
}
window.addEventListener('pointerdown', continueAction, {passive:true});
window.addEventListener('touchstart', continueAction, {passive:true});

/* small utility random used above */
function rand(min,max){ return min + Math.random()*(max-min); }

/* expose state for debug */
window._starIntro = { pointer, state, planets, STAR_LAYERS };

/* initial meteors for life */
for(let i=0;i<3;i++) spawnMeteor(off.width, off.height);
</script>
</body>
</html>
```
