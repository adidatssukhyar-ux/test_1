<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pick Your Power â€” Pixel Forest (Improved)</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root{--bg:#071026;--accent:#ffd88a;--muted:#b6c7d9;}
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Roboto,Arial;-webkit-font-smoothing:antialiased;}
  #app{position:relative;height:100vh;overflow:hidden;display:flex;align-items:center;justify-content:center;}
  canvas{display:block;width:100%;height:100%;image-rendering:pixelated;}
  .menu{position:absolute;left:50%;top:46%;transform:translate(-50%,-50%);text-align:center;color:var(--accent);text-shadow:0 12px 40px rgba(0,0,0,0.75);pointer-events:none;z-index:5;}
  .title{font-family:'Press Start 2P',monospace;font-size:44px;letter-spacing:2px;margin:0;color:var(--accent);}
  .prompt{margin-top:14px;font-family:'Press Start 2P',monospace;font-size:12px;color:var(--muted);letter-spacing:1px;}
  .menu.hidden{opacity:0;transform:translate(-50%,-56%) scale(.98);transition:opacity 260ms, transform 260ms;}
  .hint-bar{position:absolute;left:50%;transform:translateX(-50%);bottom:28px;padding:8px 14px;border-radius:10px;background:rgba(0,0,0,0.28);color:rgba(255,255,255,0.95);font-family:'Press Start 2P',monospace;font-size:11px;z-index:4;display:none}
  .hint-bar.visible{display:block}
  @media (max-width:760px){ .title{font-size:20px} .prompt{font-size:10px} }
</style>
</head>
<body>
  <div id="app" role="main" aria-label="Pick Your Power intro">
    <canvas id="bg"></canvas>
    <div class="menu" id="menu" aria-hidden="false">
      <div class="title">PICK YOUR POWER!</div>
      <div class="prompt">PRESS ANYWHERE TO CONTINUE</div>
    </div>
    <div class="hint-bar" id="hint">Move the mouse to pan the scene</div>
  </div>

<script>
/*
Improved single-file pixel forest with:
- Clear layered, rich pixel-art landscape (sky, clouds, layered ridges, big peak, deep mid trees, foreground trees).
- Smooth mouse-follow parallax (both X and Y) with stronger cinematic read.
- Low-res offscreen canvas upscaled for crisp pixel aesthetic.
- Title + "press anywhere" menu; clicking hides the menu and shows hint.
- Tweakable parameters and clean structure.
*/

const canvas = document.getElementById('bg');
const ctx = canvas.getContext('2d', { alpha: false });
const menu = document.getElementById('menu');
const hint = document.getElementById('hint');

let DPR = Math.min(window.devicePixelRatio || 1, 2);
const off = document.createElement('canvas');
const offCtx = off.getContext('2d', { alpha: false });

// configure low-res "pixel" surface (increase lowW for less chunky)
let lowW = 480;
let lowH = 270;
function fit() {
  const w = window.innerWidth, h = window.innerHeight;
  const aspect = w / h;
  lowW = Math.max(360, Math.min(960, Math.round(480 * Math.min(1.8, aspect))));
  lowH = Math.round(lowW * 9 / 16);
  off.width = lowW; off.height = lowH;
  canvas.width = lowW * DPR; canvas.height = lowH * DPR;
  canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled = false; offCtx.imageSmoothingEnabled = false;
}
window.addEventListener('resize', fit);
fit();

/* pointer & smoothing state */
const pointer = { x: window.innerWidth/2, y: window.innerHeight/2, active: false };
window.addEventListener('mousemove', e => { pointer.x = e.clientX; pointer.y = e.clientY; pointer.active = true; });
window.addEventListener('touchmove', e => { const t=e.touches[0]; if(t){ pointer.x = t.clientX; pointer.y = t.clientY; pointer.active = true; } }, {passive:true});
window.addEventListener('touchstart', e => { const t=e.touches[0]; if(t){ pointer.x = t.clientX; pointer.y = t.clientY; pointer.active = true; } }, {passive:true});

const state = { time:0, tx:0, ty:0, sx:0, sy:0 };

/* util */
function lerp(a,b,t){ return a + (b-a)*t; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rand(min,max){ return min + Math.random()*(max-min); }

/* DRAWING: layered elements for a richer landscape */

/* sky */
function drawSky(c,w,h){
  const g = c.createLinearGradient(0,0,0,h);
  g.addColorStop(0, '#fff8ee');
  g.addColorStop(0.18, '#ffddf0');
  g.addColorStop(0.46, '#ffd8ee');
  g.addColorStop(1, '#83aee3');
  c.fillStyle = g; c.fillRect(0,0,w,h);
}

/* animated soft clouds */
function drawClouds(c,w,h,t, offsetX=0){
  c.save();
  c.globalAlpha = 0.18;
  const cloudCount = 3;
  for(let i=0;i<cloudCount;i++){
    const cx = ( (t*12 + i*120) % (w + 200) ) - 100 + offsetX * (i-1) * 12;
    const cy = Math.round(h*0.12 + i*10);
    drawSoftCloud(c, cx, cy, 160 - i*18, 44 - i*6);
  }
  c.restore();
}
function drawSoftCloud(c,x,y,wid,height){
  c.fillStyle = '#fff';
  c.beginPath();
  c.ellipse(x, y, wid*0.36, height*0.7, 0, 0, Math.PI*2);
  c.ellipse(x - wid*0.25, y+6, wid*0.25, height*0.6, 0, 0, Math.PI*2);
  c.ellipse(x + wid*0.28, y+4, wid*0.22, height*0.55, 0, 0, Math.PI*2);
  c.fill();
}

/* layered distant ridges */
function drawRidges(c,w,h, ox, oy){
  drawRidge(c,w,h, Math.round(h*0.40), '#dbeefc', 8, 8, ox*0.02, oy*0.01);
  drawRidge(c,w,h, Math.round(h*0.50), '#9fc0ea', 10, 12, ox*0.05, oy*0.02);
}

/* a single ridge silhouette */
function drawRidge(c,w,h,baseY,color,peaks,amp,ox,oy){
  c.save(); c.translate(ox, oy);
  c.fillStyle = color; c.beginPath(); c.moveTo(-40,h);
  for(let i=0;i<=peaks;i++){
    const px = Math.round((i/peaks)*(w+80) - 40);
    const noise = Math.sin(i*1.1 + performance.now()*0.00008) * amp;
    const py = Math.round(baseY - Math.abs(Math.cos(i*0.7)) * (100 * (amp/8 + 1)) + noise);
    c.lineTo(px, py);
  }
  c.lineTo(w+40,h); c.closePath(); c.fill(); c.restore();
}

/* dramatic central peak (taller) */
function drawPeak(c,w,h,ox,oy){
  c.save(); c.translate(ox, oy);
  const cx = Math.round(w/2 + ox*6);
  const peakY = Math.round(h*0.66 - 260);
  const left = cx - 300, right = cx + 300;
  const gg = c.createLinearGradient(cx, peakY, cx, Math.round(h*0.66));
  gg.addColorStop(0, '#2a5f96'); gg.addColorStop(1, '#143e64');
  c.fillStyle = gg; c.beginPath(); c.moveTo(cx, peakY); c.lineTo(right, Math.round(h*0.66)); c.lineTo(left, Math.round(h*0.66)); c.closePath(); c.fill();
  // jagged snow cap
  c.fillStyle = '#fff';
  c.beginPath();
  const capBase = peakY + 72;
  const capW = 240;
  c.moveTo(cx - capW/2, capBase);
  for(let i=0;i<=10;i++){
    const t=i/10;
    const x = cx - capW/2 + t*capW;
    const y = capBase - Math.sin(t*Math.PI*2) * 18 * (0.6 + Math.random()*0.4);
    c.lineTo(Math.round(x), Math.round(y));
  }
  c.lineTo(cx + capW/2, capBase); c.lineTo(cx, peakY+10); c.closePath(); c.fill();
  c.restore();
}

/* tree bands: block-tree clusters, blossoms in near layer */
function drawTreeBands(c,w,h, ox, oy, t){
  // middle band
  drawTreeBand(c,w, Math.round(h*0.75), 12, 0.36, 0.28, 0.08, ox, oy, false, t);
  // near band with blossoms
  drawTreeBand(c,w, Math.round(h*0.84), 10, 0.64, 0.6, 0.14, ox, oy, true, t);
  // foreground band (big block trees)
  drawTreeBand(c,w, Math.round(h*0.92), 8, 0.9, 1.0, 0.28, ox, oy, true, t);
}

function drawTreeBand(c,w,baseY,count,scale,dx,dy,depthX,ox,oy,blossoms,t){
  c.save();
  // parallax translation using pointer influence (depthX stronger for near bands)
  c.translate(ox * dx * 18, oy * dy * 8);
  for(let i=0;i<count;i++){
    const t2 = i/(count-1);
    const jitter = Math.sin(t*0.6 + i*1.2) * 6;
    const x = Math.round(t2 * w + jitter + (Math.random()-0.5)*10);
    const hgt = Math.round(48 + Math.random()*112 * scale);
    drawBlockTree(c, x + Math.round((Math.random()-0.5)*16), baseY + Math.round((Math.random()-0.5)*6), hgt, blossoms && Math.random() > 0.45);
  }
  c.restore();
}

/* blocky pixel tree */
function drawBlockTree(c,x,baseY,hgt,blossoms){
  c.save(); c.translate(x, baseY);
  c.fillStyle = '#3a291e'; c.fillRect(-2,0,4, Math.round(hgt*0.26));
  const layers = 4; const baseW = Math.round(hgt*0.78);
  for(let i=0;i<layers;i++){
    const w = Math.max(8, Math.round(baseW - i*(baseW*0.2)));
    const y = -Math.round(hgt*0.14) - i * Math.round(hgt*0.22);
    const shade = i===0 ? '#2f6b42' : shadeRGB('#2f6b42', -6*i);
    c.fillStyle = shade; c.fillRect(-Math.round(w/2), y, w, Math.round(hgt*0.22));
  }
  if(blossoms){
    const petals = 6 + Math.floor(Math.random()*6);
    for(let p=0;p<petals;p++){
      const bx = Math.round((Math.random()-0.5)*(baseW*0.6));
      const by = Math.round(-Math.random()*hgt*0.6 - 8);
      c.fillStyle = (p%2===0) ? '#ffc6e1' : '#ffdbe9';
      c.fillRect(bx, by, 2, 2);
    }
  }
  c.restore();
}

/* vignette */
function drawVignette(c,w,h){
  c.globalCompositeOperation = 'multiply';
  const vg = c.createLinearGradient(0,0,0,h);
  vg.addColorStop(0, 'rgba(0,0,0,0)');
  vg.addColorStop(0.6, 'rgba(0,0,0,0.04)');
  vg.addColorStop(1, 'rgba(0,0,0,0.2)');
  c.fillStyle = vg; c.fillRect(0,0,w,h);
  c.globalCompositeOperation = 'source-over';
}

/* compose the full scene on low-res offscreen canvas */
function composeScene(c,w,h, ox, oy, time){
  drawSky(c,w,h);
  drawClouds(c,w,h,time, ox*8);
  drawRidges(c,w,h, ox, oy);
  drawPeak(c,w,h, ox*12, oy*8);
  drawTreeBands(c,w,h, ox, oy, time);
  drawVignette(c,w,h);
}

/* small shading helper */
function shadeRGB(hex, pct){
  const f = hex.replace('#','');
  const R = parseInt(f.substring(0,2),16);
  const G = parseInt(f.substring(2,4),16);
  const B = parseInt(f.substring(4,6),16);
  const t = pct/100;
  const newR = Math.round(R + ((t>0?255:0) - R) * Math.abs(t));
  const newG = Math.round(G + ((t>0?255:0) - G) * Math.abs(t));
  const newB = Math.round(B + ((t>0?255:0) - B) * Math.abs(t));
  return `rgb(${clamp(newR,0,255)},${clamp(newG,0,255)},${clamp(newB,0,255)})`;
}

/* main loop with smooth mouse-follow */
let last = performance.now();
function loop(now){
  const dt = Math.min((now - last)/1000, 0.033);
  last = now;
  state.time += dt;

  // normalized pointer -1..1
  const nx = (pointer.x / Math.max(window.innerWidth,1) - 0.5) * 2;
  const ny = (pointer.y / Math.max(window.innerHeight,1) - 0.5) * 2;

  // target offsets (amplify for cinematic effect)
  state.tx = clamp(nx * 1.15, -1, 1);
  state.ty = clamp(ny * 0.9, -1, 1);

  // smooth interpolation
  state.sx = lerp(state.sx || 0, state.tx, Math.min(1, 8*dt));
  state.sy = lerp(state.sy || 0, state.ty, Math.min(1, 8*dt));

  // map offsets to small pixel-space values for layers
  const ox = state.sx; const oy = state.sy;

  // draw to offscreen low-res canvas
  offCtx.clearRect(0,0,off.width,off.height);
  composeScene(offCtx, off.width, off.height, ox, oy, state.time);

  // upscale to visible (disable smoothing for pixel look)
  ctx.clearRect(0,0,canvas.width/DPR, canvas.height/DPR);
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(off, 0, 0, off.width, off.height, 0, 0, canvas.width/DPR, canvas.height/DPR);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* menu click to continue */
function continueAction(){
  if(!menu.classList.contains('hidden')){
    menu.classList.add('hidden');
    hint.classList.add('visible');
    setTimeout(()=> hint.classList.remove('visible'), 4200);
  }
}
window.addEventListener('pointerdown', continueAction, {passive:true});
window.addEventListener('touchstart', continueAction, {passive:true});

/* expose pointer for quick debug */
window._pixelPointer = pointer;
</script>
</body>
</html>
```
